<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>IoT Temperature & Humidity Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
  :root{
    --bg-dark: linear-gradient(135deg,#0f2027,#203a43,#2c5364);
    --bg-light: linear-gradient(135deg,#e0f7fa,#ffffff,#b2ebf2);
    --text-dark:#ffffff; --text-light:#000000;
    --card-dark:rgba(255,255,255,.08); --card-light:rgba(0,0,0,.08);
    --chip-dark:rgba(255,255,255,.12); --chip-light:rgba(0,0,0,.08);
  }
  *{box-sizing:border-box}
  body{
    margin:0; padding:24px;
    font-family:"Segoe UI",system-ui,Arial,sans-serif;
    background: var(--bg-dark);
    background-size: 200% 200%;
    animation: bgshift 18s ease infinite;
    color: var(--text-dark);
    transition: background .6s ease, color .6s ease;
  }
  body.light{
    background: var(--bg-light);
    color: var(--text-light);
  }
  @keyframes bgshift{
    0%{background-position:0% 50%}
    50%{background-position:100% 50%}
    100%{background-position:0% 50%}
  }
  h1{text-align:center;margin:0 0 6px;font-weight:800}
  .sub{text-align:center;margin-bottom:18px;opacity:.85}
  .topbar{max-width:1200px;margin:0 auto 16px;display:flex;gap:12px;justify-content:flex-end}
  .btn{border:0;border-radius:999px;padding:9px 14px;font-weight:600;cursor:pointer;transition:transform .15s ease,background .3s ease,opacity .2s ease}
  .btn:hover{transform:translateY(-1px)}
  .btn-primary{background:#ff9800;color:#fff}
  .grid{max-width:1200px;margin:0 auto;display:grid;gap:20px}
  @media (min-width:980px){.grid{grid-template-columns:1fr 1fr}}
  .card{background: var(--card-dark);backdrop-filter: blur(10px);border-radius:16px;padding:16px;box-shadow:0 10px 28px rgba(0,0,0,.25)}
  body.light .card{ background: var(--card-light); }
  .card-header{display:flex; align-items:center; justify-content:space-between; gap:8px; margin-bottom:10px;}
  .chips{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .chip{padding:6px 10px;border-radius:999px;font-size:12px;background:var(--chip-dark)}
  body.light .chip{background:var(--chip-light)}
  canvas{background:rgba(255,255,255,.04);border-radius:12px;padding:10px}
  body.light canvas{background:rgba(0,0,0,.04)}
  .mini-cards{display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:12px; margin-top:12px;}
  .mini{background: rgba(255,255,255,.06); border-radius:12px; padding:10px; text-align:center; box-shadow:0 6px 18px rgba(0,0,0,.18);}
  body.light .mini{ background: rgba(0,0,0,.06) }
  .mini h4{ margin:0 0 6px; font-size:14px; color:#ffca28 }
  .mini .icon{ font-size:20px; line-height:1; margin-bottom:6px }
  .mini p{ margin:2px 0; font-size:12px }
</style>
</head>
<body>
<h1>IoT Temperature & Humidity Dashboard</h1>
<div class="sub" id="timestamp">‚Äî</div>
<div class="topbar">
  <button class="btn btn-primary" id="themeToggle">‚òÄ Light Mode</button>
</div>

<div class="grid">
  <div class="card">
    <div class="card-header"><div class="chips"><div class="chip">Temperature</div><div class="chip">Live</div></div></div>
    <canvas id="tempChart" height="130"></canvas>
  </div>
  <div class="card">
    <div class="card-header"><div class="chips"><div class="chip">Humidity</div><div class="chip">Live</div></div></div>
    <canvas id="humidityChart" height="130"></canvas>
  </div>
  <div class="card">
    <div class="card-header"><div class="chips"><div class="chip">Current</div><div class="chip">Temperature</div></div></div>
    <h2 id="currentTemp" style="text-align:center; font-size:32px; margin:10px 0;">-- ¬∞C</h2>
  </div>
  <div class="card">
    <div class="card-header"><div class="chips"><div class="chip">Current</div><div class="chip">Humidity</div></div></div>
    <h2 id="currentHum" style="text-align:center; font-size:32px; margin:10px 0;">-- %</h2>
  </div>
  <div class="card" style="grid-column:1/-1">
    <div class="card-header"><div class="chips"><div class="chip">Forecast</div><div class="chip">Trend-based</div></div></div>
    <div class="forecast-wrap">
      <canvas id="forecastChart" height="110"></canvas>
      <div id="miniCards" class="mini-cards"></div>
    </div>
  </div>
</div>

<script>
const IN_TZ = 'Asia/Kolkata';
const API_URL = "http://172.20.10.2:5000/api/logs"; 
const MAX_POINTS = 120; 
const UPDATE_MS = 4000; 

// Clock update
function updateClock(){
  const now = new Date().toLocaleString('en-IN',{timeZone:IN_TZ, weekday:'long', year:'numeric', month:'long', day:'numeric', hour:'2-digit', minute:'2-digit', second:'2-digit', hour12:true});
  document.getElementById('timestamp').textContent = `Indian Time: ${now}`;
}
setInterval(updateClock, 1000); updateClock();

// Theme toggle
let isLight = false;
const themeBtn = document.getElementById('themeToggle');
themeBtn.addEventListener('click', ()=>{
  isLight = !isLight;
  document.body.classList.toggle('light', isLight);
  themeBtn.textContent = isLight ? 'üåô Dark Mode' : '‚òÄ Light Mode';
  syncChartTheme();
});

// Helper
const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
function linearRegression(xs, ys){
  const n=xs.length; if(n<2) return {a:0,b:ys[n-1]||0};
  let sx=0, sy=0, sxy=0, sxx=0;
  for(let i=0;i<n;i++){ const x=xs[i], y=ys[i]; sx+=x; sy+=y; sxy+=x*y; sxx+=x*x;}
  const d = n*sxx - sx*sx; if(!d) return {a:0,b:ys[n-1]};
  const a = (n*sxy - sx*sy)/d;
  const b = (sy - a*sx)/n;
  return {a,b};
}
function pickIcon(t,h){
  if(h>80)return "üåßÔ∏è";
  if(t>=34 && h<60) return "‚òÄÔ∏è";
  if(t>=30 && h>=60) return "üå§Ô∏è";
  if(t<22 && h>70) return "üå¶Ô∏è";
  return "‚õÖ";
}

// Chart setup
const palette = {
  dark:{text:'#fff', grid:'rgba(255,255,255,.18)', temp:'#ff7043', tempFill:'rgba(255,112,67,.18)', hum:'#29b6f6', humFill:'rgba(41,182,246,.18)', forecast:'#66bb6a', forecastFill:'rgba(102,187,106,.2)'},
  light:{text:'#000', grid:'rgba(0,0,0,.16)', temp:'#e65100', tempFill:'rgba(230,81,0,.16)', hum:'#0277bd', humFill:'rgba(2,119,189,.16)', forecast:'#2e7d32', forecastFill:'rgba(46,125,50,.18)'}
};

const tempCtx = document.getElementById('tempChart').getContext('2d');
const humidityCtx = document.getElementById('humidityChart').getContext('2d');
const forecastCtx = document.getElementById('forecastChart').getContext('2d');

const tempChart = new Chart(tempCtx,{
  type:'line',
  data:{labels:[], datasets:[{label:'Temperature (¬∞C)', data:[], tension:.35, borderWidth:2, pointRadius:0, borderColor: palette.dark.temp, backgroundColor: palette.dark.tempFill, fill:true}]},
  options:{animation:{duration:600,easing:'easeOutQuart'}, responsive:true, plugins:{legend:{labels:{color: palette.dark.text}}}, scales:{x:{ticks:{color: palette.dark.text}, grid:{color: palette.dark.grid}}, y:{ticks:{color: palette.dark.text}, grid:{color: palette.dark.grid}}}}
});

const humidityChart = new Chart(humidityCtx,{
  type:'line',
  data:{labels:[], datasets:[{label:'Humidity (%)', data:[], tension:.35, borderWidth:2, pointRadius:0, borderColor: palette.dark.hum, backgroundColor: palette.dark.humFill, fill:true}]},
  options:{animation:{duration:600,easing:'easeOutQuart'}, responsive:true, plugins:{legend:{labels:{color: palette.dark.text}}}, scales:{x:{ticks:{color: palette.dark.text}, grid:{color: palette.dark.grid}}, y:{ticks:{color: palette.dark.text}, grid:{color: palette.dark.grid}}}}
});

const forecastChart = new Chart(forecastCtx,{
  type:'line',
  data:{labels:[], datasets:[{label:'Predicted Temp (¬∞C)', data:[], tension:.35, borderWidth:2, pointRadius:2, borderColor: palette.dark.forecast, backgroundColor: palette.dark.forecastFill, fill:true},{label:'Predicted Humidity (%)', data:[], tension:.35, borderWidth:2, pointRadius:2, borderColor: palette.dark.hum, backgroundColor:'transparent', fill:false}]},
  options:{animation:{duration:500}, responsive:true, plugins:{legend:{labels:{color: palette.dark.text}}}, scales:{x:{ticks:{color: palette.dark.text}, grid:{color: palette.dark.grid}}, y:{ticks:{color: palette.dark.text}, grid:{color: palette.dark.grid}}}}
});

function syncChartTheme(){
  const p = isLight ? palette.light : palette.dark;
  [tempChart, humidityChart, forecastChart].forEach(ch=>{
    ch.options.plugins.legend.labels.color = p.text;
    ch.options.scales.x.ticks.color = p.text;
    ch.options.scales.y.ticks.color = p.text;
    ch.options.scales.x.grid.color = p.grid;
    ch.options.scales.y.grid.color = p.grid;
  });
  tempChart.data.datasets[0].borderColor = p.temp; tempChart.data.datasets[0].backgroundColor = p.tempFill;
  humidityChart.data.datasets[0].borderColor = p.hum; humidityChart.data.datasets[0].backgroundColor = p.humFill;
  forecastChart.data.datasets[0].borderColor = p.forecast; forecastChart.data.datasets[0].backgroundColor = p.forecastFill;
  forecastChart.data.datasets[1].borderColor = p.hum;
  tempChart.update(); humidityChart.update(); forecastChart.update();
}

// Fetch and render live data
async function fetchLive(){
  try{
    const res = await fetch(API_URL);
    const data = await res.json();
    data.sort((a,b)=> new Date(a.timestamp) - new Date(b.timestamp));

    const labels = data.map(d=> d.timestamp);
    const temps  = data.map(d=> Number(d.temperature));
    const hums   = data.map(d=> Number(d.humidity));

    const start = Math.max(0, labels.length - MAX_POINTS);
    const lbl = labels.slice(start).map(t=>{
      const date = new Date(t); // parsed as UTC
      return date.toLocaleTimeString('en-IN',{timeZone:IN_TZ,hour:'2-digit',minute:'2-digit'});
    });

    tempChart.data.labels = lbl; tempChart.data.datasets[0].data = temps.slice(start);
    humidityChart.data.labels = lbl; humidityChart.data.datasets[0].data = hums.slice(start);
    tempChart.update(); humidityChart.update();

    if(temps.length>0 && hums.length>0){
      const latestTemp = temps[temps.length-1]; const latestHum = hums[hums.length-1];
      const tempEl = document.getElementById("currentTemp"); const humEl = document.getElementById("currentHum");
      tempEl.textContent = `${latestTemp.toFixed(1)} ¬∞C`;
      tempEl.style.color = latestTemp<18?"#1e88e5":latestTemp<=30?"#43a047":"#e53935";
      humEl.textContent = `${latestHum.toFixed(1)} %`;
      humEl.style.color = latestHum<30?"#f57c00":latestHum<=70?"#43a047":"#1e88e5";
    }

    computeForecast(labels, temps, hums);
  }catch(e){console.error('Fetch error:',e);}
}

// Forecast using linear regression
let forecastRange = 7;
function computeForecast(labels, temps, hums){
  if(labels.length<3) return;
  const xs = labels.map(t=>new Date(t).getTime());
  const {a:at,b:bt}=linearRegression(xs,temps);
  const {a:ah,b:bh}=linearRegression(xs,hums);
  const dayMs=24*60*60*1000; const nowMs=Date.now();
  const out=[];
  for(let i=1;i<=15;i++){
    const t=nowMs+i*dayMs;
    const temp=clamp(at*t+bt,-10,60);
    const hum=clamp(ah*t+bh,0,100);
    const tMin=clamp(temp-1.6,-20,60); const tMax=clamp(temp+1.8,-20,60);
    const hMin=clamp(hum-6,0,100); const hMax=clamp(hum+6,0,100);
    out.push({
      label:new Date(t).toLocaleDateString('en-IN',{weekday:'short', month:'short', day:'numeric', timeZone:IN_TZ}),
      t:Number(temp.toFixed(1)), h:Number(hum.toFixed(0)),
      tMin:Number(tMin.toFixed(1)), tMax:Number(tMax.toFixed(1)),
      hMin:Math.round(hMin), hMax:Math.round(hMax),
      icon: pickIcon(temp,hum)
    });
  }
  renderForecast(out);
}

function renderForecast(allDays){
  const view=allDays.slice(0, forecastRange);
  forecastChart.data.labels=view.map(d=>d.label);
  forecastChart.data.datasets[0].data=view.map(d=>d.t);
  forecastChart.data.datasets[1].data=view.map(d=>d.h);
  forecastChart.update();
  const mini = document.getElementById('miniCards'); mini.innerHTML='';
  view.forEach(d=>{
    const div=document.createElement('div'); div.className='mini';
    div.style.opacity='0'; div.style.transform='translateY(6px)';
    div.innerHTML=`<h4>${d.label}</h4><div class="icon">${d.icon}</div><p>üå°Ô∏è <strong>${d.tMin}‚Äì${d.tMax}¬∞C</strong></p><p>üíß <strong>${d.hMin}‚Äì${d.hMax}%</strong></p>`;
    mini.appendChild(div);
    requestAnimationFrame(()=>{div.style.transition='transform .3s ease, opacity .35s ease'; div.style.opacity='1'; div.style.transform='translateY(0)';});
  });
}

// Forecast range toggle (optional)
setInterval(fetchLive, UPDATE_MS); fetchLive();
</script>
</body>
</html>
